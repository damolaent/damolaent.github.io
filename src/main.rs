use chrono;
use clap::{Parser, Subcommand};
use serde::Deserialize;
use std::fs;
use std::fs::read_to_string;
use std::io::Write;
use toml;

// Import our custom modules
mod markdown;
use markdown::{parse_page_markdown, parse_post_markdown, Post};

// Import the server module
mod server;
use server::start_server;

/// Struct to hold site configuration loaded from `config.toml`
#[derive(Deserialize)]
struct SiteConfig {
    site: SiteInfo,
    links: Links,
    analytics: Analytics,
}

/// Holds site metadata like title, description, etc.
#[derive(Deserialize)]
struct SiteInfo {
    title: String,
    description: String,
    author: String,
    author_glitch_effect: bool,
    profile_picture: String,
    base_url: String,
    og_image: Option<String>,
}

/// Holds external links
#[derive(Deserialize)]
struct Links {
    github: String,
    twitter: String,
}

#[derive(Deserialize)]
struct Analytics {
    plausible_domain: String,
    cloudflare_beacon_token: String,
}

#[derive(Parser)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Build the static site (parse Markdown & generate HTML)
    Build,
    /// Start a local server to preview the site at http://localhost:8464
    Serve,
}

fn main() {
    let cli = Cli::parse();

    // Load the configuration from `config.toml`
    let config = load_config();

    match cli.command {
        Commands::Build => {
            println!("Building site...");

            // Ensure `docs/posts` folder exists
            fs::create_dir_all("docs/posts")
                .expect("Failed to create or verify docs/posts directory");

            // Collect blog posts to build index.html
            let mut posts_collected: Vec<Post> = Vec::new();

            // Scan `content/` for .md files
            if let Ok(entries) = fs::read_dir("content") {
                for entry in entries.flatten() {
                    let path = entry.path();
                    if path.extension().and_then(|e| e.to_str()) == Some("md") {
                        let file_path = path.to_string_lossy().to_string();

                        // Check special pages
                        if file_path.ends_with("about.md") {
                            generate_about(&file_path, &config);
                        } else {
                            // Treat everything else as a blog post
                            match parse_post_markdown(&file_path) {
                                Ok(post) => {
                                    // Build the final HTML for this post using wrap_in_template
                                    // We'll pass in the post's title and a custom body content.
                                    let post_body = format!(
                                        "<h1>{title}</h1>
                                         <p><strong>By {author}</strong> - {date} - {read_time} min read</p>
                                         {content}",
                                        title = post.front_matter.title,
                                        author = post.front_matter.author,
                                        date = post.front_matter.date,
                                        read_time = post.reading_time,
                                        content = post.content,
                                    );

                                    let post_url = post
                                        .file_name
                                        .strip_prefix("docs")
                                        .unwrap_or(&post.file_name);

                                    let final_html = wrap_in_template(
                                        &post.front_matter.title,
                                        post.front_matter.description.as_deref().unwrap_or("A blog post generated by Xeniria — a fast, minimal Rust-based static site generator. https://github.com/0xh4ty/xeniria"),
                                        &post_body,
                                        "../",
                                        post_url,
                                        &config
                                    );

                                    // Write it out to post.file_name
                                    let mut file = fs::File::create(&post.file_name)
                                        .expect("Failed to create post file");
                                    file.write_all(final_html.as_bytes())
                                        .expect("Failed to write post file");

                                    println!("Generated: {}", post.file_name);

                                    // Add to list for index.html
                                    posts_collected.push(post);
                                }
                                Err(e) => {
                                    println!("Error parsing post {}: {}", file_path, e);
                                }
                            }
                        }
                    }
                }
            }

            // Generate index.html to link to all posts
            generate_index(&posts_collected, &config);

            generate_posts(&posts_collected, &config);

            generate_sitemap(&posts_collected, &config);

            generate_category_pages(&posts_collected, &config);

            println!("Site build complete!");
        }

        Commands::Serve => {
            // Start server on a custom port
            println!("Starting server at http://localhost:8464...");
            let port = 8464;
            if let Err(e) = start_server(port) {
                eprintln!("Server error: {}", e);
            }
        }
    }
}

/// Load configuration from `config.toml`
fn load_config() -> SiteConfig {
    let config_contents = read_to_string("config.toml").expect("Failed to read config.toml");
    toml::from_str(&config_contents).expect("Failed to parse config.toml")
}

/// Helper function to generate the full HTML layout
/// Takes a `title` (for <title>) and a `body_content` (the unique page/post body).
fn wrap_in_template(
    title: &str,
    meta_description: &str,
    body_content: &str,
    prefix: &str,
    page_url: &str,
    config: &SiteConfig,
) -> String {
    // Optional Plausible Analytics script
    let plausible_script = if !config.analytics.plausible_domain.is_empty() {
        format!(
        "<script async defer data-domain=\"{}\" src=\"https://plausible.io/js/script.js\"></script>",
        config.analytics.plausible_domain
    )
    } else {
        String::new()
    };
    let cloudflare_script = if !config.analytics.cloudflare_beacon_token.is_empty() {
        format!(
        "<script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{{\"token\": \"{}\"}}'></script>",
        config.analytics.cloudflare_beacon_token
    )
    } else {
        String::new()
    };
    // Determine OG image URL: use og_image if present, else profile_picture
    let og_image_path = config
        .site
        .og_image
        .as_deref()
        .unwrap_or(&config.site.profile_picture);
    let og_image_url = format!(
        "{}/{}",
        config.site.base_url.trim_end_matches('/'),
        og_image_path.trim_start_matches('/')
    );

    // Twitter image URL is same — Twitter and OG should match
    let twitter_image_url = og_image_url.clone();

    format!(
"<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <meta name='description' content='{meta_description}'>
    <meta name='generator' content='Xeniria — https://github.com/0xh4ty/xeniria'>
    <title>{title}</title>

    <!-- Canonical URL -->
    <link rel='canonical' href='{base_url}{page_url}'>

    <!-- Open Graph (OG) meta -->
    <meta property='og:title' content='{title}'>
    <meta property='og:description' content='{meta_description}'>
    <meta property='og:type' content='article'>
    <meta property='og:url' content='{base_url}{page_url}'>
    <meta property='og:image' content='{og_image_url}'>

    <!-- Twitter meta -->
    <meta name='twitter:card' content='summary_large_image'>
    <meta name='twitter:title' content='{title}'>
    <meta name='twitter:description' content='{meta_description}'>
    <meta name='twitter:image' content='{twitter_image_url}'>

    <link rel='stylesheet' href='{prefix}assets/css/pico.min.css'>
    <link rel='stylesheet' href='{prefix}assets/styles.css'>
    <link rel='stylesheet' href='{prefix}assets/prism-custom-theme.css'>
    <link rel='stylesheet' href='{prefix}assets/prism/prism-line-numbers.min.css'>

    <script src='{prefix}assets/prism/prism.min.js'></script>
    <script src='{prefix}assets/prism/prism-solidity.min.js'></script>
    <script src='{prefix}assets/prism/prism-line-numbers.min.js'></script>

    {plausible_script}
    {cloudflare_script}
</head>
<body>
<header class='container'>
  <nav class='flex-nav'>
    <!-- Left side: brand or home icon -->
    <ul class='nav-left'>
      <li><a href='{prefix}index.html'><svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-home'><path d='M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z'></path><polyline points='9 22 9 12 15 12 15 22'></polyline></svg></a></li>
    </ul>

    <!-- Right side: links -->
    <ul class='nav-links' id='navLinks'>
      <li><a href='{prefix}index.html'>Home</a></li>
      <li><a href='{prefix}about.html'>About</a></li>
      <li><a href='{prefix}cryptography.html'>Cryptography</a></li>
      <li><a href='{prefix}ethereum.html'>Ethereum</a></li>
      <li><a href='{prefix}blockchain.html'>Blockchain</a></li>
      <li><a href='{prefix}computing.html'>Computing</a></li>

    </ul>

    <!-- Hamburger Button (hidden on large screens) -->
    <button
      class='hamburger'
      aria-label='Toggle Menu'
      onclick='toggleMenu()'>
      <svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-menu'><line x1='3' y1='12' x2='21' y2='12'></line><line x1='3' y1='6' x2='21' y2='6'></line><line x1='3' y1='18' x2='21' y2='18'></line></svg>
    </button>
  </nav>
</header>
<main class='container'>
{body_content}
</main>
<footer class='container' style='text-align: center;'>
    <p>
        <a href='{github}'><svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-github'><path d='M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22'></path></svg></a>
        &nbsp;|&nbsp;
        <a href='{twitter}'><svg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' class='feather feather-twitter'><path d='M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z'></path></svg></a>
    </p>
    <p class='footer-credit'>
        © 2025 <a href='{twitter}'>{author}</a>. Powered by <a href='https://github.com/0xh4ty/xeniria'>Xeniria</a>.
    </p>
</footer>
<script>
  function toggleMenu() {{
    let nav = document.getElementById('navLinks');
    nav.classList.toggle('open');
  }}
</script>
</body>
</html>",
        title = title,
        meta_description = meta_description,
        base_url = config.site.base_url,
        page_url = page_url,
        prefix = prefix,
        body_content = body_content,
        author = config.site.author,
        github = config.links.github,
        twitter = config.links.twitter
    )
}

/// Generate `about.html` from `about.md`
fn generate_about(file_path: &str, config: &SiteConfig) {
    match parse_page_markdown(file_path) {
        Ok(page) => {
            // Prepare a body with a heading, author, and page.content
            let about_body = format!(
                "<h1>{title}</h1>
                 <p>By {author}</p>
                 {content}",
                title = page.front_matter.title,
                author = page.front_matter.author,
                content = page.content
            );

            let final_html = wrap_in_template(&page.front_matter.title, page.front_matter.description.as_deref().unwrap_or("About page generated by Xeniria — a fast, minimal Rust-based static site generator. https://github.com/0xh4ty/xeniria"), &about_body, "", "/about.html", config);

            let mut file =
                fs::File::create("docs/about.html").expect("Failed to create about.html");
            file.write_all(final_html.as_bytes())
                .expect("Failed to write about.html");

            println!("Generated: docs/about.html");
        }
        Err(e) => {
            println!("Error parsing About page {}: {}", file_path, e);
        }
    }
}


/// Generate `index.html` listing all blog posts
fn generate_index(posts: &Vec<Post>, config: &SiteConfig) {
    // Clone & sort posts by date DESC (assuming YYYY-MM-DD format)
    let mut sorted_posts = posts.clone();
    sorted_posts.sort_by(|a, b| b.front_matter.date.cmp(&a.front_matter.date));

    let author_html = if config.site.author_glitch_effect {
        format!(
            "<h2 class='profile-name hero glitch layers' data-text='{author}'>
                <span>{author}</span>
            </h2>",
            author = config.site.author
        )
    } else {
        format!(
            "<h2 class='profile-name'>{author}</h2>",
            author = config.site.author
        )
    };

    // Build the "Recent Posts" list
    let mut recent_posts_html = format!(
        "<div class='profile-container'>
            <img class='profile-img' src='{profile_picture}' alt='Profile Picture'>
            {author_html}
            <p class='profile-desc'>{description}</p>
        </div>
        <div class='recent-posts'>
        <h3>Recent Posts</h3>
        <ul>",
        profile_picture = config.site.profile_picture,
        author_html = author_html,
        description = config.site.description,
    );

    for post in sorted_posts.iter().take(5) {
        recent_posts_html.push_str("<hr>\n");
        let link_path = post.file_name.replace("docs/", "");
        recent_posts_html.push_str(&format!(
            "<li class='post-item'>
                <span class='post-title'>
                    <a href='{link}'>{title}</a>
                </span>
                <span class='post-date'>
                    {date}
                </span>
            </li>\n",
            link = link_path,
            title = post.front_matter.title,
            date = post.front_matter.date
        ));
    }

    recent_posts_html.push_str(
        "</ul>
        <div style='text-align:center;'>
          <a href='posts.html'>See all posts</a>
        </div>
        </div>",
    );

    // Wrap the "recent_posts_html" in the global template
    let final_html = wrap_in_template(
        &config.site.title,
        &config.site.description,
        &recent_posts_html,
        "",
        "/",
        config,
    );

    // Write to `docs/index.html`
    let mut file = fs::File::create("docs/index.html").expect("Failed to create docs/index.html");
    file.write_all(final_html.as_bytes())
        .expect("Failed to write index.html");

    println!("Generated: docs/index.html");
}

/// Generate `posts.html` listing all posts grouped by year
fn generate_posts(posts: &Vec<Post>, config: &SiteConfig) {
    // Clone & sort posts by date DESC (newest first)
    let mut sorted_posts = posts.clone();
    sorted_posts.sort_by(|a, b| b.front_matter.date.cmp(&a.front_matter.date));

    // Start HTML content
    let mut posts_html =
        String::from("<div class='posts-container'>\n<h1 style='text-align: center;'>Posts</h1>\n");

    let mut last_year = String::new();

    for post in &sorted_posts {
        let post_year = &post.front_matter.date[..4]; // Extract YYYY from YYYY-MM-DD

        // If it's a new year, add a heading with extra spacing
        if post_year != last_year {
            posts_html.push_str(&format!("<h3 class='post-year'>{}</h3>\n", post_year));
            last_year = post_year.to_string();
        }

        let link_path = post.file_name.replace("docs/", "");
        posts_html.push_str(&format!(
            "<hr>\n\
             <div class='post-item'>\n\
                <a href='{link}' class='post-title'>{title}</a>\n\
                <span class='post-date'>{date}</span>\n\
            </div>\n",
            link = link_path,
            title = post.front_matter.title,
            date = post.front_matter.date
        ));
    }

    // Close the `posts-container` div
    posts_html.push_str("</div>\n");

    // Wrap in template
    let final_html = wrap_in_template("All Posts", "Posts page generated by Xeniria — a fast, minimal Rust-based static site generator. https://github.com/0xh4ty/xeniria", &posts_html, "", "/posts.html", config);

    // Write to `docs/posts.html`
    let mut file = fs::File::create("docs/posts.html").expect("Failed to create docs/posts.html");
    file.write_all(final_html.as_bytes())
        .expect("Failed to write posts.html");

    println!("Generated: docs/posts.html");
}

use std::collections::HashMap;

/// Generate pages per category (e.g. cryptography.html, blockchain.html)
fn generate_category_pages(posts: &Vec<Post>, config: &SiteConfig) {
    let mut categories: HashMap<String, Vec<&Post>> = HashMap::new();

    // Group posts by category
    for post in posts {
        if let Some(category) = &post.front_matter.category {
            categories.entry(category.clone()).or_default().push(post);
        }
    }

    // Generate one HTML page per category
    for (category, posts) in categories {
        let mut html = format!("<div class='category-container'><h1>{}</h1>\n<ul>", category);

        // Sort posts newest-first
        let mut sorted_posts = posts.clone();
        sorted_posts.sort_by(|a, b| b.front_matter.date.cmp(&a.front_matter.date));

        for post in sorted_posts {
            let link = post.file_name.replace("docs/", "");
            html.push_str(&format!(
                "<li class='post-item'>
                    <a href='{link}'>{title}</a>
                    <span class='post-date'>{date}</span>
                 </li>",
                link = link,
                title = post.front_matter.title,
                date = post.front_matter.date
            ));
        }

        html.push_str("</ul></div>");

        // Wrap in your site template
        let final_html = wrap_in_template(
            &format!("{} Articles", category),
            &format!("All posts under the {} category", category),
            &html,
            "",
            &format!("/{}.html", category.to_lowercase()),
            config,
        );

        // Write to docs/<category>.html
        let output_path = format!("docs/{}.html", category.to_lowercase());
        let mut file = fs::File::create(&output_path)
            .expect(&format!("Failed to create {}", output_path));
        file.write_all(final_html.as_bytes())
            .expect("Failed to write category page");

        println!("Generated: {}", output_path);
    }
}


fn generate_sitemap(posts: &Vec<Post>, config: &SiteConfig) {
    let base_url = &config.site.base_url;
    // Start XML
    let mut sitemap = String::from(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\
         <urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n",
    );

    // Static pages
    let pages = vec!["/", "/about.html","/posts.html", "/cryptography.html", "/ethereum.html", "/blockchain.html", "/computing.html"];

    for path in pages {
        sitemap.push_str(&format!(
            "  <url>\n    <loc>{}{}</loc>\n    <lastmod>{}</lastmod>\n  </url>\n",
            base_url,
            path,
            chrono::Utc::now().format("%Y-%m-%d")
        ));
    }

    // Blog posts
    for post in posts {
        let post_url = post.file_name.replace("docs", "");
        sitemap.push_str(&format!(
            "  <url>\n    <loc>{}{}</loc>\n    <lastmod>{}</lastmod>\n  </url>\n",
            base_url,
            post_url,
            chrono::Utc::now().format("%Y-%m-%d")
        ));
    }

    // Close XML
    sitemap.push_str("</urlset>");

    // Write to docs/sitemap.xml
    let mut file = fs::File::create("docs/sitemap.xml").expect("Failed to create sitemap.xml");
    file.write_all(sitemap.as_bytes())
        .expect("Failed to write sitemap.xml");

    println!("Generated: docs/sitemap.xml");
}
